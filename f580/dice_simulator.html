<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 互動骰子</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000; /* 改為黑色 */
        }
        canvas {
            display: block;
        }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #f0f0f0; /* 改為淺色字方便閱讀 */
            font-family: sans-serif;
            font-size: 16px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            text-align: center;
        }
        button {
            margin: 5px;
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #fff;
        }
        button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="info">使用滑鼠左鍵拖曳以旋轉，滾輪縮放</div>
    <div id="controls">
        <button id="rotate-forward">向前 (+X)</button>
        <button id="rotate-backward">向後 (-X)</button>
        <button id="rotate-left">向左 (-Z)</button>
        <button id="rotate-right">向右 (+Z)</button>
        <br>
        <button id="reset">重置</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let scene, camera, renderer, cube, controls;
        let isAnimating = false;
        let targetQuaternion = new THREE.Quaternion();
        let initialQuaternion;

        const btnFwd = document.getElementById('rotate-forward');
        const btnBwd = document.getElementById('rotate-backward');
        const btnLeft = document.getElementById('rotate-left');
        const btnRight = document.getElementById('rotate-right');
        const btnReset = document.getElementById('reset');

        function init() {
            // 1. 場景設定
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // 改為黑色

            // 加入座標軸輔助 (長度為 5)
            const axesHelper = new THREE.AxesHelper( 5 );
            scene.add( axesHelper );

            // 載入字型並建立座標軸標籤
            const fontLoader = new FontLoader();
            fontLoader.load('https://unpkg.com/three@0.164.1/examples/fonts/helvetiker_regular.typeface.json', function (font) {
                const textParams = { font: font, size: 0.5, height: 0.1, curveSegments: 12 };
                const xLabel = new THREE.Mesh(new TextGeometry('X', textParams), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                xLabel.position.set(5.2, 0, 0); scene.add(xLabel);
                const yLabel = new THREE.Mesh(new TextGeometry('Y', textParams), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
                yLabel.position.set(0, 5.2, 0); scene.add(yLabel);
                const zLabel = new THREE.Mesh(new TextGeometry('Z', textParams), new THREE.MeshBasicMaterial({ color: 0x0000ff }));
                zLabel.position.set(0, 0, 5.2); scene.add(zLabel);
            });

            // 2. 相機設定
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 6); camera.lookAt(scene.position);

            // 3. 渲染器設定
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 4. 光源設定
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(1, 2, 3); scene.add(directionalLight);

            // 5. 建立骰子材質 (根據題目展開圖修正)
            const materials = [
                createDiceFace(2), createDiceFace(5), createDiceFace(3), 
                createDiceFace(4), createDiceFace(1), createDiceFace(6)
            ];

            // 6. 建立骰子幾何體與網格
            const geometry = new THREE.BoxGeometry(3, 3, 3);
            cube = new THREE.Mesh(geometry, materials);

            // 根據題目要求「1朝上, 4朝前, 2朝右」設定初始旋轉
            initialQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            cube.quaternion.copy(initialQuaternion);
            targetQuaternion.copy(initialQuaternion);

            scene.add(cube);

            // 7. 控制器設定
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;

            // 8. 按鈕事件監聽
            btnFwd.addEventListener('click', () => rotateCube('x', Math.PI / 2));
            btnBwd.addEventListener('click', () => rotateCube('x', -Math.PI / 2));
            btnLeft.addEventListener('click', () => rotateCube('z', Math.PI / 2));
            btnRight.addEventListener('click', () => rotateCube('z', -Math.PI / 2));
            btnReset.addEventListener('click', resetCube);

            // 9. 監聽視窗大小變化
            window.addEventListener('resize', onWindowResize, false);
        }

        function setButtonsDisabled(disabled) {
            btnFwd.disabled = disabled;
            btnBwd.disabled = disabled;
            btnLeft.disabled = disabled;
            btnRight.disabled = disabled;
            btnReset.disabled = disabled;
        }

        function rotateCube(axis, angle) {
            if (isAnimating) return;
            isAnimating = true;
            setButtonsDisabled(true);

            const rotationAxis = new THREE.Vector3();
            if (axis === 'x') rotationAxis.set(1, 0, 0);
            if (axis === 'z') rotationAxis.set(0, 0, 1);

            const deltaQuaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle);
            targetQuaternion.premultiply(deltaQuaternion);
        }

        function resetCube() {
            if (isAnimating) return;
            isAnimating = true;
            setButtonsDisabled(true);
            targetQuaternion.copy(initialQuaternion);
        }

        function createDiceFace(number) {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const context = canvas.getContext('2d');
            const width = canvas.width, height = canvas.height, radius = 30;
            context.fillStyle = 'white';
            context.beginPath();
            context.moveTo(radius, 0); context.lineTo(width - radius, 0);
            context.quadraticCurveTo(width, 0, width, radius);
            context.lineTo(width, height - radius);
            context.quadraticCurveTo(width, height, width - radius, height);
            context.lineTo(radius, height);
            context.quadraticCurveTo(0, height, 0, height - radius);
            context.lineTo(0, radius); context.quadraticCurveTo(0, 0, radius, 0);
            context.closePath(); context.fill();
            context.fillStyle = 'black';
            const dotRadius = 22;
            const positions = {
                1: [[0.5, 0.5]], 2: [[0.25, 0.25], [0.75, 0.75]],
                3: [[0.25, 0.25], [0.5, 0.5], [0.75, 0.75]],
                4: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]],
                5: [[0.25, 0.25], [0.75, 0.25], [0.5, 0.5], [0.25, 0.75], [0.75, 0.75]],
                6: [[0.25, 0.25], [0.75, 0.25], [0.25, 0.5], [0.75, 0.5], [0.25, 0.75], [0.75, 0.75]]
            };
            if (positions[number]) {
                positions[number].forEach(([x, y]) => {
                    context.beginPath();
                    context.arc(x * 256, y * 256, dotRadius, 0, Math.PI * 2);
                    context.fill();
                });
            }
            return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(canvas) });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isAnimating) {
                cube.quaternion.slerp(targetQuaternion, 0.1);
                if (cube.quaternion.angleTo(targetQuaternion) < 0.01) {
                    cube.quaternion.copy(targetQuaternion);
                    isAnimating = false;
                    setButtonsDisabled(false);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
